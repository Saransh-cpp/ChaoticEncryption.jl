var documenterSearchIndex = {"docs":
[{"location":"apidocs/algorithms/#Encryption/decryption-algorithms","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"","category":"section"},{"location":"apidocs/algorithms/#Substitution","page":"Encryption/decryption algorithms","title":"Substitution","text":"","category":"section"},{"location":"apidocs/algorithms/#Encryption","page":"Encryption/decryption algorithms","title":"Encryption","text":"","category":"section"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_encryption(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_encryption-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_encryption","text":"substitution_encryption(image, keys; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Encrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_encryption(img, keys)\n[ Info: ENCRYPTING\n[ Info: ENCRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_encryption!(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_encryption!-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_encryption!","text":"substitution_encryption!(image, keys; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Encrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_encryption!(img, keys)\n[ Info: ENCRYPTING\n[ Info: ENCRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\njulia> img  # inplace\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/#Decryption","page":"Encryption/decryption algorithms","title":"Decryption","text":"","category":"section"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_decryption(\n    image::Union{String,Array{RGB{N0f8},2}},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./decrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_decryption-Tuple{Union{String, Matrix{RGB{N0f8}}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_decryption","text":"substitution_decryption(image, keys; path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\nimage::Union{String,Array{RGB{N0f8},2}}: The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Decrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_decryption(img, keys)\n[ Info: DECRYPTING\n[ Info: DECRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_decryption!(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./decrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_decryption!-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_decryption!","text":"substitution_decryption!(image, keys; path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\nimage::Union{String,Array{RGB{N0f8},2}}: The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Decrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_decryption!(img, keys)\n[ Info: DECRYPTING\n[ Info: DECRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\njulia> img  # inplace\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/prngs/#Pseudo-Random-Number-Generators","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"","category":"section"},{"location":"apidocs/prngs/#Logistic-map","page":"Pseudo-Random Number Generators","title":"Logistic map","text":"","category":"section"},{"location":"apidocs/prngs/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"logistic_key(\n    x_init::Float64,\n    r::Float64,\n    num_keys::Int64;\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"apidocs/prngs/#ChaoticEncryption.logistic_key-Tuple{Float64, Float64, Int64}","page":"Pseudo-Random Number Generators","title":"ChaoticEncryption.logistic_key","text":"logistic_key(x_init, r, num_keys; scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates a vector of pseudo-random keys using the Logistic Map.\n\nThe equation -\n\nx_n+1 = r * x_n * (1 - x_n)\n\nArguments\n\nx_init::Float64: Initial value of x. x ϵ (0, 1).\nr::Float64: A constant value. Values > 4 usually results in pseudo-random numbers.\nnum_keys::Int64: Number of keys to be generated.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nkeys::Vector{Int64}:: Generated pseudo-random keys.\n\nExample\n\njulia> logistic_key(0.01, 3.97, 20)\n20-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n 200\n 217\n  97\n 132\n 134\n 100\n 135\n 232\n 122\n 102\n\n\n\n\n\n","category":"method"},{"location":"apidocs/prngs/#Lorenz-system-of-differential-equations","page":"Pseudo-Random Number Generators","title":"Lorenz system of differential equations","text":"","category":"section"},{"location":"apidocs/prngs/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"lorenz_key(\n    x_init::Float64,\n    y_init::Float64,\n    z_init::Float64,\n    num_keys::Int64;\n    α::Float64=10.0,\n    ρ::Float64=28.0,\n    β::Float64=2.667,\n    dt::Float64=0.01,\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"apidocs/prngs/#ChaoticEncryption.lorenz_key-Tuple{Float64, Float64, Float64, Int64}","page":"Pseudo-Random Number Generators","title":"ChaoticEncryption.lorenz_key","text":"lorenz_key(x_init, y_init, z_init, num_keys; α=10.0, ρ=28.0, β=2.667, dt=0.01, scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates 3 vectors of pseudo-random numbers using Lorenz system of differential equations.\n\nThe equations -\n\nfracdxdt = α * (y - x)\n\nfracdydt = x * (ρ - z) - y\n\nfracdzdt = x * y - β * z\n\nArguments\n\nx_init::Float64: Initial value of x.\ny_init::Float64: Initial value of y.\nz_init::Float64: Initial value of z.\nnum_keys::Int64: Number of keys (in a single list) to be generated.\nα::Float64: Constant associated with Lorenz system of differential equations.\nρ::Float64: Constant associated with Lorenz system of differential equations.\nβ::Float64: Constant associated with Lorenz system of differential equations.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nx::Vector{Int64}: Generated pseudo-random keys corresponding to x values.\ny::Vector{Int64}: Generated pseudo-random keys corresponding to y values.\nz::Vector{Int64}: Generated pseudo-random keys corresponding to z values.\n\nExample\n\njulia> lorenz_key(0.01, 0.02, 0.03, 20)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179, 85, 19, 24, 44, 71, 210, 238, 152, 22, 27], [0, 0, 240, 55, 25, 163, 89, 243, 123, 5, 197, 64, 227, 54, 188, 226, 154, 134, 64, 69], [0, 0, 80, 227, 178, 204, 89, 33, 144, 139, 105, 208, 108, 155, 61, 254, 57, 102, 149, 47])\n\n\n\n\n\n","category":"method"},{"location":"#ChaoticEncryption.jl","page":"Home","title":"ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"Encrypt and decrypt image files using Pseudo-Random Number Generators and various encryption techniques! ChaoticEncryption.jl comes loaded with Pseudo-Random Number Generators and various encryption techniques, which can be used to encrypt and decrypt any image file. The package is under active development, but the existing API is stable and might not change significantly.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is available on Julia's Registry!","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ChaoticEncryption\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"For developer installation or installation from source, refer here.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example for a particular function is available in the function's docstring itself. These docstrings or the API documentation is also available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other than the docstrings, comprehensive Jupyter notebooks displaying the features of ChaoticEncryption.jl are available in the examples directory.","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run the tests, execute the following in your Julia REPL -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]test ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on tests is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To run calculate coverage while running tests, execute the following in your Julia REPL -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"Coverage\")\njulia> Pkg.test(\"ChaoticEncryption\"; coverage=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on coverage is available here.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation is available here - https://saransh-cpp.github.io/ChaoticEncryption.jl/dev/","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation can be built locally by executing -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The deployment will be visible on the webpage served at http://127.0.0.1:8000.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on documentation is available here.","category":"page"},{"location":"#Infrastructure","page":"Home","title":"Infrastructure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A detailed guide on ChaoticEncryption.jl's infrastructure is available here.","category":"page"},{"location":"#Results","page":"Home","title":"Results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"S.No. Original Image Image Dimensions Encrypted Image Decrypted Image PRNG used Algorithm used\n1 (Image: image) (225, 225) (Image: encrypted) (Image: decrypted) Logistic Map (logistic_key) Substitution (substitution_encryption, substitution_decryption)","category":"page"},{"location":"#Contributing-to-ChaoticEncryption.jl","page":"Home","title":"Contributing to ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All contributions to this repository are welcome. Please go through our contribution guidelines to make the whole process smoother.","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer Documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"API documentation for ChaoticEncryption.jl developers.","category":"page"},{"location":"devdocs/#Encryption/decryption-algorithms","page":"Developer Documentation","title":"Encryption/decryption algorithms","text":"","category":"section"},{"location":"devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"ChaoticEncryption._substitution(\n    image::Union{String,Array{RGB{N0f8},2}},\n    keys::Vector{Int64},\n    type::String;\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"devdocs/#ChaoticEncryption._substitution-Tuple{Union{String, Matrix{RGB{N0f8}}}, Vector{Int64}, String}","page":"Developer Documentation","title":"ChaoticEncryption._substitution","text":"_substitution(image, keys, type; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption/decryption on a given image with the given keys.\n\nSee substitution_encryption and substitution_decryption for more details.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\ntype::String: Can be \"encryption\" or \"decryption\".\npath_for_result::String: The path for storing the encrypted image.\ninplace::Boolean: Perform substitution on the provided image.\n\n\n\n\n\n","category":"method"}]
}
