var documenterSearchIndex = {"docs":
[{"location":"#ChaoticEncryption.jl","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"Encrypt and decrypt image files using Pseudo-Random Number Generators!","category":"page"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"CurrentModule = ChaoticEncryption","category":"page"},{"location":"#Index","page":"ChaoticEncryption.jl","title":"Index","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"","category":"page"},{"location":"#Pseudo-Random-Number-Generators","page":"ChaoticEncryption.jl","title":"Pseudo-Random Number Generators","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"logistic_key(\n    x_init::Float64,\n    r::Float64,\n    num_keys::Int64;\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"#ChaoticEncryption.logistic_key-Tuple{Float64, Float64, Int64}","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.logistic_key","text":"logistic_key(x_init, r, num_keys; scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates a vector of pseudo-random keys using the Logistic Map.\n\nThe equation -\n\nx_n+1 = r * x_n * (1 - x_n)\n\nArguments\n\nx_init::Float64: Initial value of x. x ϵ (0, 1).\nr::Float64: A constant value. Values > 4 usually results in pseudo-random numbers.\nnum_keys::Int64: Number of keys to be generated.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nkeys::Vector{Int64}:: Generated pseudo-random keys.\n\nExample\n\njulia> using ChaoticEncryption\n\njulia> logistic_key(0.01, 3.97, 20)\n20-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n 200\n 217\n  97\n 132\n 134\n 100\n 135\n 232\n 122\n 102\n\n\n\n\n\n","category":"method"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"lorenz_key(\n    x_init::Float64,\n    y_init::Float64,\n    z_init::Float64,\n    num_keys::Int64;\n    α::Float64=10.0,\n    ρ::Float64=28.0,\n    β::Float64=2.667,\n    dt::Float64=0.01,\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"#ChaoticEncryption.lorenz_key-Tuple{Float64, Float64, Float64, Int64}","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.lorenz_key","text":"lorenz_key(x_init, y_init, z_init, num_keys; α=10.0, ρ=28.0, β=2.667, dt=0.01, scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates 3 vectors of pseudo-random numbers using Lorenz system of differential equations.\n\nThe equations -\n\nfracdxdt = α * (y - x)\n\nfracdydt = x * (ρ - z) - y\n\nfracdzdt = x * y - β * z\n\nArguments\n\nx_init::Float64: Initial value of x.\ny_init::Float64: Initial value of y.\nz_init::Float64: Initial value of z.\nnum_keys::Int64: Number of keys (in a single list) to be generated.\nα::Float64: Constant associated with Lorenz system of differential equations.\nρ::Float64: Constant associated with Lorenz system of differential equations.\nβ::Float64: Constant associated with Lorenz system of differential equations.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nx::Vector{Int64}: Generated pseudo-random keys corresponding to x values.\ny::Vector{Int64}: Generated pseudo-random keys corresponding to y values.\nz::Vector{Int64}: Generated pseudo-random keys corresponding to z values.\n\nExample\n\njulia> using ChaoticEncryption\n\njulia> lorenz_key(0.01, 0.02, 0.03, 20)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179, 85, 19, 24, 44, 71, 210, 238, 152, 22, 27], [0, 0, 240, 55, 25, 163, 89, 243, 123, 5, 197, 64, 227, 54, 188, 226, 154, 134, 64, 69], [0, 0, 80, 227, 178, 204, 89, 33, 144, 139, 105, 208, 108, 155, 61, 254, 57, 102, 149, 47])\n\n\n\n\n\n","category":"method"},{"location":"#Encryption-methods","page":"ChaoticEncryption.jl","title":"Encryption methods","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"substitution_encryption(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"#ChaoticEncryption.substitution_encryption-Tuple{Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}, Vector{Int64}}","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.substitution_encryption","text":"substitution_encryption(image, keys; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nReturns\n\nencryptedImage::Array{RGB{N0f8}, 2}: Encrypted image.\n\nExample\n\njulia> using Images, ChaoticEncryption\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_encryption(img, keys)\nENCRYPTING\nENCRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"substitution_decryption(\n    image,\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./decrypted.png\"\n)","category":"page"},{"location":"#ChaoticEncryption.substitution_decryption-Tuple{Any, Vector{Int64}}","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.substitution_decryption","text":"substitution_decryption(image, keys; path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\nimage: ::String or ::Array{RGB{N0f8},2}. The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nReturns\n\ndecryptedImage::Array{RGB{N0f8}, 2}: Decrypted image.\n\nExample\n\njulia> using Images, ChaoticEncryption\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_decryption(img, keys)\nDECRYPTING\nDECRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.902,0.902,0.902)\n RGB{N0f8}(0.918,0.918,0.918)     RGB{N0f8}(0.753,0.753,0.753)\n RGB{N0f8}(0.027,0.027,0.027)     RGB{N0f8}(0.051,0.051,0.051)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.02,0.02,0.02)\n RGB{N0f8}(0.369,0.369,0.369)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.576,0.576,0.576)  …  RGB{N0f8}(0.769,0.769,0.769)\n RGB{N0f8}(0.894,0.894,0.894)     RGB{N0f8}(0.463,0.463,0.463)\n RGB{N0f8}(0.376,0.376,0.376)     RGB{N0f8}(0.757,0.757,0.757)\n RGB{N0f8}(0.631,0.631,0.631)     RGB{N0f8}(0.325,0.325,0.325)\n RGB{N0f8}(0.647,0.647,0.647)     RGB{N0f8}(0.655,0.655,0.655)\n ⋮                             ⋱\n RGB{N0f8}(0.086,0.086,0.086)     RGB{N0f8}(0.098,0.098,0.098)\n RGB{N0f8}(0.769,0.769,0.769)     RGB{N0f8}(0.251,0.251,0.251)\n RGB{N0f8}(0.459,0.459,0.459)     RGB{N0f8}(0.016,0.016,0.016)\n RGB{N0f8}(0.302,0.302,0.302)     RGB{N0f8}(0.804,0.804,0.804)\n RGB{N0f8}(0.153,0.153,0.153)  …  RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.78,0.78,0.78)        RGB{N0f8}(0.8,0.8,0.8)\n RGB{N0f8}(0.075,0.075,0.075)     RGB{N0f8}(0.988,0.988,0.988)\n RGB{N0f8}(0.208,0.208,0.208)     RGB{N0f8}(0.498,0.498,0.498)\n RGB{N0f8}(0.839,0.839,0.839)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"}]
}
