var documenterSearchIndex = {"docs":
[{"location":"tutorials/prng/#Pseudo-Random-Number-Generators","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"In the following example, we will explore the PRNGs available in ChaoticEncryption.jl. The API documentation for ChaoticEncryption.jl is available here.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Let us start by adding in the julia packages we will be needing -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"# install TestImages for this tutorial\n# julia> using Pkg\n# julia> Pkg.add(\"TestImages\")\n# install ChaoticEncryption.jl if you haven't already!\n# julia> Pkg.add(\"ChaoticEncryption\")\n\njulia> using TestImages, ChaoticEncryption\n","category":"page"},{"location":"tutorials/prng/#PRNGs-in-ChaoticEncryption.jl","page":"Pseudo-Random Number Generators","title":"PRNGs in ChaoticEncryption.jl","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Currently, ChaoticEncryption.jl includes 2 PRNGs, which are- ","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Logistic Map\nLorenz System of Differential Equations","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"We will be adding more of them soon! If you stumble upon an interesting PRNG, feel free to create an issue or a pull request for the same!","category":"page"},{"location":"tutorials/prng/#Logistic-Map","page":"Pseudo-Random Number Generators","title":"Logistic Map","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"As per the documentation, logistic_key generates a vectors of pseudo-random numbers using the Logistic Map.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The function uses the following equation to generate pseudo-random numbers -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x_n+1 = r * x_n * (1 - x_n)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The function takes in the following arguments -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x_init::Float64: Initial value of x. x ϵ (0, 1).\nr::Float64: A constant value. Values > 4 usually results in pseudo-random numbers.\nnum_keys::Int64: Number of keys to be generated.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"And returns the following Vector -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"keys::Vector{Int64}:: Generated pseudo-random keys.","category":"page"},{"location":"tutorials/prng/#Using-logistic_key","page":"Pseudo-Random Number Generators","title":"Using logistic_key","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"After going through the documentation, let us use the function logistic_key with the following aarguments -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x_init = 0.01\nr = 3.97\nnum_keys = 20","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> keys = logistic_key(0.01, 3.97, 20)\n20-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n 200\n 217\n  97\n 132\n 134\n 100\n 135\n 232\n 122\n 102","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"This returns a 1 dimensional Vector of pseudo-random Int64 elements ranging from 0 - 255 (as the RGB values of an image range from 0 - 255)!","category":"page"},{"location":"tutorials/prng/#Generating-pseudo-random-keys-for-an-image","page":"Pseudo-Random Number Generators","title":"Generating pseudo-random keys for an image","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Now we can try to generate a pseudo-random key for each pixel in a given image. Let us load an image using the TestImages package for this!","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> img = testimage(\"cameraman\");\n\njulia> height, width = size(img)\n(512, 512)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The image can be viewed using ImageView.jl -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> using ImageView\n\njulia> imshow(img)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"(Image: image)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Generating a key for each pixel in the image","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> keys = logistic_key(0.01, 3.67, height * width)\n262144-element Vector{Int64}:\n   0\n  68\n 135\n  20\n  13\n 140\n 197\n 182\n 248\n 229\n   ⋮\n 168\n 182\n  77\n  83\n  74\n 176\n  27\n 251\n 206","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"We can now use these keys to encrypt the image! Encryption and decryption will be covered in another example :)","category":"page"},{"location":"tutorials/prng/#Lorenz-System-of-Differential-Equations","page":"Pseudo-Random Number Generators","title":"Lorenz System of Differential Equations","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"As per the documentation, lorenz_key generates 3 vectors of pseudo-random numbers using Lorenz system of differential equations.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The function uses the following system of differential equations to generate pseudo-random numbers -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"fracdxdt = α * (y - x)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"fracdydt = x * (ρ - z) - y","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"fracdzdt = x * y - β * z","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The function takes in the following arguments -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x_init::Float64: Initial value of x.\ny_init::Float64: Initial value of y.\nz_init::Float64: Initial value of z.\nnum_keys::Int64: Number of keys (in a single list) to be generated.\nα::Float64: Constant associated with Lorenz system of differential equations.\nρ::Float64: Constant associated with Lorenz system of differential equations.\nβ::Float64: Constant associated with Lorenz system of differential equations.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"And returns the following Vectors","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x::Vector{Int64}: Generated pseudo-random keys corresponding to x values.\ny::Vector{Int64}: Generated pseudo-random keys corresponding to y values.\nz::Vector{Int64}: Generated pseudo-random keys corresponding to z values.","category":"page"},{"location":"tutorials/prng/#Using-lorenz_key","page":"Pseudo-Random Number Generators","title":"Using lorenz_key","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"After going through the documentation, let us use the function lorenz_key with the following aarguments -","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"x_init = 0.01\ny_init = 0.02\nz_init = 0.03\nnum_keys = 20","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"You can play with other arguments as well!","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> keys = lorenz_key(0.01, 0.02, 0.03, 20)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179, 85, 19, 24, 44, 71, 210, 238, 152, 22, 27], [0, 0, 240, 55, 25, 163, 89, 243, 123, 5, 197, 64, 227, 54, 188, 226, 154, 134, 64, 69], [0, 0, 80, 227, 178, 204, 89, 33, 144, 139, 105, 208, 108, 155, 61, 254, 57, 102, 149, 47])","category":"page"},{"location":"tutorials/prng/#Generating-pseudo-random-keys-for-an-image-2","page":"Pseudo-Random Number Generators","title":"Generating pseudo-random keys for an image","text":"","category":"section"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Now we can try to generate a pseudo-random key for each pixel in a given image. Let us load an image using the TestImages package for this!","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> img = testimage(\"cameraman\");\n\njulia> height, width = size(img)\n(512, 512)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"Generating a key for each pixel in the image","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> x, y, z = lorenz_key(0.01, 0.02, 0.03, height * width)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179  …  46, 94, 18, 206, 68, 98, 72, 10, 248, 136], [0, 0, 240, 55, 25, 163, 89, 243, 123, 5  …  4, 112, 116, 100, 108, 92, 236, 80, 152, 144], [0, 0, 80, 227, 178, 204, 89, 33, 144, 139  …  128, 48, 176, 128, 176, 72, 168, 32, 208, 112])","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"lorenz_key returns a Tuple with each element being an Vector{Int64}. Thus, it returns a variable of the type Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}.","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"julia> x\n262144-element Vector{Int64}:\n   0\n   0\n 256\n  24\n 129\n  42\n  54\n 134\n  43\n 179\n   ⋮\n  94\n  18\n 206\n  68\n  98\n  72\n  10\n 248\n 136","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"A notebook version of this tutorial is available here. Don't forget to star ChaoticEncryption.jl :)","category":"page"},{"location":"tutorials/prng/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"The complete API documentation is available here. ","category":"page"},{"location":"apidocs/algorithms/#Encryption/decryption-algorithms","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"","category":"section"},{"location":"apidocs/algorithms/#Substitution","page":"Encryption/decryption algorithms","title":"Substitution","text":"","category":"section"},{"location":"apidocs/algorithms/#Encryption","page":"Encryption/decryption algorithms","title":"Encryption","text":"","category":"section"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_encryption(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_encryption-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_encryption","text":"substitution_encryption(image, keys; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Encrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_encryption(img, keys)\n[ Info: ENCRYPTING\n[ Info: ENCRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)\n RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)\n RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)\n RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)\n RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)\n RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)\n RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)\n RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)\n RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)\n RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)\n ⋮                             ⋱\n RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)\n RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)\n RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)\n RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)\n RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)\n RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)\n RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)\n RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_encryption!(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./encrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_encryption!-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_encryption!","text":"substitution_encryption!(image, keys; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Encrypted image.\n\nExample\n\n```jldoctest julia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\") 225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:  RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)  ⋮                             ⋱  RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img) (225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width) 50625-element Vector{Int64}:    0   44    7   26   14  224   16  250  162  211    ⋮   72  255   80   84   21  154  197   82  147\n\njulia> substitution_encryption!(img, keys) [ Info: ENCRYPTING [ Info: ENCRYPTED 225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:  RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)  RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)  RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)  RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)  RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)  RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)  RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)  RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)  RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)  RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)  ⋮                             ⋱  RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)  RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)  RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)  RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)  RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)  RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)  RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)  RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)  RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)\n\njulia> img  # inplace 225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:  RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)  RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)  RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)  RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)  RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)  RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)  RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)  RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)  RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)  RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)  ⋮                             ⋱  RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)  RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)  RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)  RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)  RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)  RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)  RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)  RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)  RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)```\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/#Decryption","page":"Encryption/decryption algorithms","title":"Decryption","text":"","category":"section"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_decryption(\n    image::Union{String,Array{RGB{N0f8},2}},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./decrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_decryption-Tuple{Union{String, Matrix{RGB{N0f8}}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_decryption","text":"substitution_decryption(image, keys; path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\nimage::Union{String,Array{RGB{N0f8},2}}: The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Decrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_decryption(img, keys)\n[ Info: DECRYPTING\n[ Info: DECRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)\n RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)\n RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)\n RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)\n RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)\n RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)\n RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)\n RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)\n RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)\n RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)\n ⋮                             ⋱\n RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)\n RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)\n RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)\n RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)\n RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)\n RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)\n RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)\n RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"apidocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"substitution_decryption!(\n    image::Array{RGB{N0f8},2},\n    keys::Array{Int64, 1};\n    path_for_result::String=\"./decrypted.png\"\n)","category":"page"},{"location":"apidocs/algorithms/#ChaoticEncryption.substitution_decryption!-Tuple{Matrix{RGB{N0f8}}, Vector{Int64}}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption.substitution_decryption!","text":"substitution_decryption!(image, keys; path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\nimage::Union{String,Array{RGB{N0f8},2}}: The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nReturns\n\nimage::Array{RGB{N0f8}, 2}: Decrypted image.\n\nExample\n\njulia> using Images\n\njulia> img = load(\"../test_images/camera.jfif\")\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.608,0.608,0.608)     RGB{N0f8}(0.0,0.0,0.0)\n ⋮                             ⋱\n RGB{N0f8}(0.4,0.4,0.4)           RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.447,0.447,0.447)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.427,0.427,0.427)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.451,0.451,0.451)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.51,0.51,0.51)     …  RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.537,0.537,0.537)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.412,0.412,0.412)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.149,0.149,0.149)     RGB{N0f8}(0.0,0.0,0.0)\n RGB{N0f8}(0.0,0.0,0.0)           RGB{N0f8}(0.0,0.0,0.0)\n\njulia> height, width = size(img)\n(225, 225)\n\njulia> keys = logistic_key(0.01, 3.97, height * width)\n50625-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n   ⋮\n  72\n 255\n  80\n  84\n  21\n 154\n 197\n  82\n 147\n\njulia> substitution_decryption!(img, keys)\n[ Info: DECRYPTING\n[ Info: DECRYPTED\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)\n RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)\n RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)\n RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)\n RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)\n RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)\n RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)\n RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)\n RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)\n RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)\n ⋮                             ⋱\n RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)\n RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)\n RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)\n RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)\n RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)\n RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)\n RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)\n RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)\n\njulia> img  # inplace\n225×225 Array{RGB{N0f8},2} with eltype RGB{N0f8}:\n RGB{N0f8}(0.608,0.608,0.608)  …  RGB{N0f8}(0.839,0.839,0.839)\n RGB{N0f8}(0.718,0.718,0.718)     RGB{N0f8}(0.361,0.361,0.361)\n RGB{N0f8}(0.612,0.612,0.612)     RGB{N0f8}(0.055,0.055,0.055)\n RGB{N0f8}(0.506,0.506,0.506)     RGB{N0f8}(0.58,0.58,0.58)\n RGB{N0f8}(0.584,0.584,0.584)     RGB{N0f8}(0.631,0.631,0.631)\n RGB{N0f8}(0.482,0.482,0.482)  …  RGB{N0f8}(0.639,0.639,0.639)\n RGB{N0f8}(0.545,0.545,0.545)     RGB{N0f8}(0.196,0.196,0.196)\n RGB{N0f8}(0.38,0.38,0.38)        RGB{N0f8}(0.047,0.047,0.047)\n RGB{N0f8}(0.224,0.224,0.224)     RGB{N0f8}(0.847,0.847,0.847)\n RGB{N0f8}(0.282,0.282,0.282)     RGB{N0f8}(0.827,0.827,0.827)\n ⋮                             ⋱\n RGB{N0f8}(0.573,0.573,0.573)     RGB{N0f8}(0.282,0.282,0.282)\n RGB{N0f8}(0.361,0.361,0.361)     RGB{N0f8}(1.0,1.0,1.0)\n RGB{N0f8}(0.847,0.847,0.847)     RGB{N0f8}(0.314,0.314,0.314)\n RGB{N0f8}(0.349,0.349,0.349)     RGB{N0f8}(0.329,0.329,0.329)\n RGB{N0f8}(0.984,0.984,0.984)  …  RGB{N0f8}(0.082,0.082,0.082)\n RGB{N0f8}(0.031,0.031,0.031)     RGB{N0f8}(0.604,0.604,0.604)\n RGB{N0f8}(0.071,0.071,0.071)     RGB{N0f8}(0.773,0.773,0.773)\n RGB{N0f8}(0.765,0.765,0.765)     RGB{N0f8}(0.322,0.322,0.322)\n RGB{N0f8}(0.902,0.902,0.902)     RGB{N0f8}(0.576,0.576,0.576)\n\n\n\n\n\n","category":"method"},{"location":"devdocs/algorithms/#Encryption/decryption-algorithms","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"","category":"section"},{"location":"devdocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"Developer documentation for encryption and decryption algorithms.","category":"page"},{"location":"devdocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"These lower level APIs can also be used by the users, but are not recommended for beginners.","category":"page"},{"location":"devdocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"ChaoticEncryption._substitution(\n    image::Union{String,Array{RGB{N0f8},2}},\n    keys::Vector{Int64},\n    type::Symbol;\n    path_for_result::String=\"./encrypted.png\",\n    inplace=false,\n)","category":"page"},{"location":"devdocs/algorithms/#ChaoticEncryption._substitution-Tuple{Union{String, Matrix{RGB{N0f8}}}, Vector{Int64}, Symbol}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption._substitution","text":"_substitution(image, keys, type; path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption/decryption on a given image with the given keys.\n\nSee substitution_encryption and substitution_decryption for more details.\n\nArguments\n\nimage::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\ntype::Symbol: Can be :encrypt or :decrypt.\npath_for_result::String: The path for storing the encrypted image.\ninplace::Boolean: Perform substitution on the provided image.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/algorithms/","page":"Encryption/decryption algorithms","title":"Encryption/decryption algorithms","text":"ChaoticEncryption._substitute_pixel(\n    pixel::RGB,\n    key::Int64\n)","category":"page"},{"location":"devdocs/algorithms/#ChaoticEncryption._substitute_pixel-Tuple{RGB, Int64}","page":"Encryption/decryption algorithms","title":"ChaoticEncryption._substitute_pixel","text":"_substitute_pixel(pixel::RGB, key::Int64)\n\nReturns the pixel after XORing the R, G, and B values with the key. Specifically developed to return an Array (or the complete image) of XORed RGB values in one go.\n\nSee _substitution for more details.\n\nArguments\n\npixel::RGB: Pixel value with r, g, and b components.\nkey::Int64: The key.\n\nReturns\n\npixel::RGB: Substituted pixel.\n\n\n\n\n\n","category":"method"},{"location":"apidocs/prngs/#Pseudo-Random-Number-Generators","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"","category":"section"},{"location":"apidocs/prngs/#Logistic-map","page":"Pseudo-Random Number Generators","title":"Logistic map","text":"","category":"section"},{"location":"apidocs/prngs/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"logistic_key(\n    x_init::Float64,\n    r::Float64,\n    num_keys::Int64;\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"apidocs/prngs/#ChaoticEncryption.logistic_key-Tuple{Float64, Float64, Int64}","page":"Pseudo-Random Number Generators","title":"ChaoticEncryption.logistic_key","text":"logistic_key(x_init, r, num_keys; scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates a vector of pseudo-random keys using the Logistic Map.\n\nThe equation -\n\nx_n+1 = r * x_n * (1 - x_n)\n\nArguments\n\nx_init::Float64: Initial value of x. x ϵ (0, 1).\nr::Float64: A constant value. Values > 4 usually results in pseudo-random numbers.\nnum_keys::Int64: Number of keys to be generated.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nkeys::Vector{Int64}:: Generated pseudo-random keys.\n\nExample\n\njulia> logistic_key(0.01, 3.97, 20)\n20-element Vector{Int64}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n 200\n 217\n  97\n 132\n 134\n 100\n 135\n 232\n 122\n 102\n\n\n\n\n\n","category":"method"},{"location":"apidocs/prngs/#Lorenz-system-of-differential-equations","page":"Pseudo-Random Number Generators","title":"Lorenz system of differential equations","text":"","category":"section"},{"location":"apidocs/prngs/","page":"Pseudo-Random Number Generators","title":"Pseudo-Random Number Generators","text":"lorenz_key(\n    x_init::Float64,\n    y_init::Float64,\n    z_init::Float64,\n    num_keys::Int64;\n    α::Float64=10.0,\n    ρ::Float64=28.0,\n    β::Float64=2.667,\n    dt::Float64=0.01,\n    scaling_factor::Float64=10.0^16,\n    upper_bound::Float64=256.0\n)","category":"page"},{"location":"apidocs/prngs/#ChaoticEncryption.lorenz_key-Tuple{Float64, Float64, Float64, Int64}","page":"Pseudo-Random Number Generators","title":"ChaoticEncryption.lorenz_key","text":"lorenz_key(x_init, y_init, z_init, num_keys; α=10.0, ρ=28.0, β=2.667, dt=0.01, scaling_factor=10.0^16, upper_bound=256.0)\n\nGenerates 3 vectors of pseudo-random numbers using Lorenz system of differential equations.\n\nThe equations -\n\nfracdxdt = α * (y - x)\n\nfracdydt = x * (ρ - z) - y\n\nfracdzdt = x * y - β * z\n\nArguments\n\nx_init::Float64: Initial value of x.\ny_init::Float64: Initial value of y.\nz_init::Float64: Initial value of z.\nnum_keys::Int64: Number of keys (in a single list) to be generated.\nα::Float64: Constant associated with Lorenz system of differential equations.\nρ::Float64: Constant associated with Lorenz system of differential equations.\nβ::Float64: Constant associated with Lorenz system of differential equations.\nscaling_factor::Float64=10.0^16: Factor to be multiplied to the generated value of pseudo-random   number. Ideally, the factor should be > upper_bound.\nupper_bound::Float64=256.0: Upper bound of keys (not included). Use 256 for encrypting images   as the RGB values of a pixel varies from 0 to 255.\n\nReturns\n\nx::Vector{Int64}: Generated pseudo-random keys corresponding to x values.\ny::Vector{Int64}: Generated pseudo-random keys corresponding to y values.\nz::Vector{Int64}: Generated pseudo-random keys corresponding to z values.\n\nExample\n\njulia> lorenz_key(0.01, 0.02, 0.03, 20)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179, 85, 19, 24, 44, 71, 210, 238, 152, 22, 27], [0, 0, 240, 55, 25, 163, 89, 243, 123, 5, 197, 64, 227, 54, 188, 226, 154, 134, 64, 69], [0, 0, 80, 227, 178, 204, 89, 33, 144, 139, 105, 208, 108, 155, 61, 254, 57, 102, 149, 47])\n\n\n\n\n\n","category":"method"},{"location":"tutorials/substitution/#Substitution-Encryption","page":"Substitution algorithm","title":"Substitution Encryption","text":"","category":"section"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"In the following tutorial, we will encrypt and decrypt an image using the substitution algorithm. ChaoticEncryption.jl, internally, XORs each pixel with the provided key and replaces or substitues it in the position of original pixel. The API documentation for ChaoticEncryption.jl is available here.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Let us start by adding in the julia packages we will be needing -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"# install TestImages for this tutorial\n# julia> using Pkg\n# julia> Pkg.add(\"TestImages\")\n# install ChaoticEncryption.jl if you haven't already!\n# julia> Pkg.add(\"ChaoticEncryption\")\n\njulia> using TestImages, ChaoticEncryption\n","category":"page"},{"location":"tutorials/substitution/#Generating-keys","page":"Substitution algorithm","title":"Generating keys","text":"","category":"section"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The first step in the process of encryption would be to generate the required number of keys. This can be done using the PRNGs available in ChaoticEncryption.jl. A detailed example describing the Pseudo-Random Number Generators available in ChaoticEncryption.jl is available here.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Let's load up an image using TestImages package!","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> img = testimage(\"mandrill\");\n\njulia> height, width = size(img)\n(512, 512)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The image can be viewed using ImageView.jl -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> using ImageView\n\njulia> imshow(img)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"(Image: image)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Now we can use these dimensions to generate random keys!","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> key = logistic_key(0.01, 3.67, height * width)\n262144-element Vector{Int64}:\n   0\n  68\n 135\n  20\n  13\n 140\n 197\n 182\n 248\n 229\n   ⋮\n 168\n 182\n  77\n  83\n  74\n 176\n  27\n 251\n 206","category":"page"},{"location":"tutorials/substitution/#Encryption","page":"Substitution algorithm","title":"Encryption","text":"","category":"section"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Now we can proceed ahead and encrypt our images using the substitution algorithm! ChaoticEncryption.jl provides an elegant way to perform this algorithm using the function substitution_encryption.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The first step (as always) would be to look at the documentation, or the docstring, of substitution_encryption. According to the documentation, substitution_encryption iterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"It takes in the following arguments -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"image::Array{RGB{N0f8},2}: A loaded image.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"And returns the encrypted image -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"image::Array{RGB{N0f8}, 2}: Encrypted image.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"We can use the function substitution_encryption by passing in a loaded image and an array of keys.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The function -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Returns the encrypted image.\nSaves the encrypted image (the filename or the path can be passed as an argument too).","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> enc = substitution_encryption(img, key)\n[ Info: ENCRYPTING\n[ Info: ENCRYPTED","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The encrypted image -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> imshow(enc)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"(Image: image)","category":"page"},{"location":"tutorials/substitution/#Decryption","page":"Substitution algorithm","title":"Decryption","text":"","category":"section"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"We can similarly use the substitution_decryption function to decrypt our images!","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The first step (again) would be to look at the documentation, or the docstring, of substitution_decryption.  According to the documentation (again), subsitution_decryption iterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"I takes in the arguments -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"image::Union{String,Array{RGB{N0f8},2}}: The path to the image or the loaded image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"And returns the decrypted image -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"image::Array{RGB{N0f8}, 2}: Decrypted image.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"We can use the function substitution_decryption by passing in the path of the encrypted image and an array of keys.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The function -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Returns the decrypted image.\nSaves the decrypted image (the filename or the path can be passed as an argument too).","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The documentation also says that we can pass an Array of type Array{RGB{N0f8},2} as an image, which means a loaded image! Let us try this!","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> dec = substitution_decryption(enc, key)\n[ Info: DECRYPTING\n[ Info: DECRYPTED","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The encrypted image -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> imshow(dec)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"(Image: image)","category":"page"},{"location":"tutorials/substitution/#In-place-substitution","page":"Substitution algorithm","title":"In-place substitution","text":"","category":"section"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"Additionally, ChaoticEncryption.jl also comes with in-place encryption and decryption methods. substitution_encryption! and substitution_decryption! acts on the image variable passed into them, rather than creating a copy of the same.","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"This speeds up your code by a huge factor, and should be used wherever possible! The methods can be used in the following way -","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"julia> substitution_encryption!(img, key)\n\njulia> img  # the original img variable will be edited inplace","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"A notebook version of this tutorial is available here. Don't forget to star ChaoticEncryption.jl :)","category":"page"},{"location":"tutorials/substitution/","page":"Substitution algorithm","title":"Substitution algorithm","text":"The complete API documentation is available here. ","category":"page"},{"location":"#ChaoticEncryption.jl","page":"Home","title":"ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"Encrypt and decrypt image files using Pseudo-Random Number Generators and various encryption techniques! ChaoticEncryption.jl comes loaded with Pseudo-Random Number Generators and various encryption techniques, which can be used to encrypt and decrypt any image file. The package is under active development, but the existing API is stable and might not change significantly.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is available on Julia's Registry!","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ChaoticEncryption\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"For developer installation or installation from source, refer here.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example for a particular function is available in the function's docstring itself. These docstrings or the API documentation is also available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other than the docstrings, comprehensive Jupyter notebooks displaying the features of ChaoticEncryption.jl are available in the examples directory.","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run the tests, execute the following in your Julia REPL -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]test ChaoticEncryption","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on tests is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To run calculate coverage while running tests, execute the following in your Julia REPL -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"Coverage\")\njulia> Pkg.test(\"ChaoticEncryption\"; coverage=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on coverage is available here.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation is available here - https://saransh-cpp.github.io/ChaoticEncryption.jl/dev/","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation can be built locally by executing -","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The deployment will be visible on the webpage served at http://127.0.0.1:8000.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on documentation is available here.","category":"page"},{"location":"#Infrastructure","page":"Home","title":"Infrastructure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A detailed guide on ChaoticEncryption.jl's infrastructure is available here.","category":"page"},{"location":"#Results","page":"Home","title":"Results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"S.No. Original Image Image Dimensions Encrypted Image Decrypted Image PRNG used Algorithm used\n1 (Image: image) (225, 225) (Image: encrypted) (Image: decrypted) Logistic Map (logistic_key) Substitution (substitution_encryption, substitution_decryption)","category":"page"},{"location":"#Contributing-to-ChaoticEncryption.jl","page":"Home","title":"Contributing to ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All contributions to this repository are welcome. Please go through our contribution guidelines to make the whole process smoother.","category":"page"}]
}
